= Deploy a web service in Azure with Terraform and Packer

== The overall solution

image::images/d.png[Overall design]


== 1. Deploy an azure policy
The details are available in the solution folder under C1-Azure Infrastructure Operations


=== 1.1 Goal
Create a policy that ensures all indexed resources in your subscription have tags and deny deployment if they do not.

=== 1.2 Solution
This has been implemented through terraform. The tagging-policy.tf define the policy and tagging-policy-assignment.tf applies this to the subscription level

.Compliance to requirements 

* [x] Write a policy definition to deny the creation of resources that do to have tags (terraform file tagging-policy.tf)

* [x] Apply the policy definition to the subscription with same name tagging policy .  ```policy_definition_id = azurerm_policy_definition.tagging-policy.id``` relates the above policy with this.

* [x] Testing
This is  tested by executing in bash

[source]
----
# az policy assignment list
----
image::images/c.png[a diagram shows policy assignment]

== 2. Packer template

=== 2.1 Goal

The first thing we're going to want to do is use Packer to create a server image, ensuring that the provided application is included in the template. 

=== 2.2 Solution

.Compliance to requirements 

Refer to the packer folder in this project to see the packer details. Note that the resource-group.tf file create a resource group

[source]
----
resource "azurerm_resource_group" "rg_web" {
  name     = "${var.prefix}-rg"
  location = var.location
}
----
The var.prefix (Refer variables.tf and terraform.auto.tfvars) has been set as 'udacity'. So the resource group name will be udacity-rg

* [x] Use Ubuntu 18.04-LTS as SKU - You can see the server.json in line 17
* [x] Ensure that busybox provisioners requirements are incorporated

[source]
----
	"provisioners": [{
		"inline": [
			"echo 'Hello, World!' > index.html",
			"nohup busybox httpd -f -p 80 &"
		],
		"inline_shebang": "/bin/sh -x",
		"type": "shell"
	}]
----
* [x] Ensure that resource group is sane as specified in terraform- The resource-group.tf can ve verified 

== 3. Terraform Template

=== 3.1 Goal

Terraform template will allow us to reliably create, update, and destroy our infrastructure. In this example, we want to use the skills we've built with variables and loops, along with our knowledge of Azure infrastructure, to deploy a web app that has been loaded into our Packer template already.

Before we get started, we'll need to verify that the policy we deployed in an earlier lesson (that one that requires tags) is still available using the Azure CLI, and include a screenshot of that policy output in our repository.

=== 3.2 Solution

.Compliance to requirements 

* [x] Create resource group.  The resource-group.tf foes this 

* [x] Create a virtual network and subnet. See the networks.tf file

The below two creates the required vnet and subnets. The CIDR ranges are configurable through the variables 

```
resource "azurerm_virtual_network" "net_web" 
resource "azurerm_subnet" "internal" 
```

* [x] Create network security group - The nsg.tf file creates the NSG (Network Security Group)

```
# This  is the NSG
resource "azurerm_network_security_group" "allow_access" 
# Rule 1 allow 80 port access
resource "azurerm_network_security_rule" "allow_access_from_intenet_80" 
# Rule 2 allow all access within VNET
resource "azurerm_network_security_rule" "allow_access_from_vm_on_subnet"

```
* [x] Create a public IP - This (networks.tf). This will be assigned to a NIC (below)
```
resource "azurerm_public_ip" "web-svc-lb-ip" {
#...
#...
}

```

* [x] Create network interface and assign the IP created above 
The file networks.tf gives details , note the ip_configuration block for details on the how the IP is assigned to the NIC

```
resource "azurerm_network_interface" "main" {
 #...
 #...
 ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.internal.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.web-svc-lb-ip.id
  }
  #...
}web_svc_port
```
* [x] Create LB  - The implementation is available  in web-lb.tf. The frontend_ip_configuration assigns the public Ip to  LB 
```
resource "azurerm_lb" "web-svc-lb" {
#...
#...
frontend_ip_configuration {
    name                 = "PublicIPAddress"
    public_ip_address_id = azurerm_public_ip.web-svc-lb-ip.id
  }
#....  

}
```
* [x] Backend pool (ref web-lb.tf) assigned to the LB in the previous step
```
resource "azurerm_lb_backend_address_pool" "web-svc-lb-backend" {
  loadbalancer_id = azurerm_lb.web-svc-lb.id
  name            = "BackEndAddressPool"
}
```
* [x] A health probe is created and assigned to LB (Best practice - web-lb.tf). The port is set in the variable default 80
```
resource "azurerm_lb_probe" "web_svc_health_probe" {
  resource_group_name = azurerm_resource_group.rg_web.name
  loadbalancer_id     = azurerm_lb.web-svc-lb.id
  name                = "web-http-probe"
  port                = var.web_svc_port
}
```
 

